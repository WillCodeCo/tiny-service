##
# AUTOGENERATED CODE FILE
##
# from titan.tiny_service.events.event_class_codegen import EventField, EventClassCodegen
# 
# def generate_code():
#     yield from EventClassCodegen.generate_imports()
#     yield from EventClassCodegen.generate_code('PlayerXWonGameEvent', [])
#     yield from EventClassCodegen.generate_code('PlayerOWonGameEvent', [])
#     yield from EventClassCodegen.generate_code('NeitherPlayerWonGameEvent', [])
#     yield from EventClassCodegen.generate_code('ScoreboardWasUpdatedEvent', [   EventField.int('x_score'),
#                                                                                 EventField.int('o_score')   ])
#     yield f"EVENT_TYPES = (PlayerXWonGameEvent, PlayerOWonGameEvent, ScoreboardWasUpdatedEvent)"
##
import typing
import msgpack
import io

from titan.tiny_service.events import Event

class PlayerXWonGameEvent(tuple, Event):
    """Tuple Class definition for PlayerXWonGameEvent"""

    def __new__(cls, event_id: str):
        try:
            assert isinstance(event_id, str), f'Expected `event_id` to be of type `str` not `{type(event_id)}`'
            return super().__new__(cls, (event_id, ))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 1:
            raise ValueError
        return cls(event_id=tuple_value[0])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def event_id(self) -> str:
        return self[0]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'event_id': self.event_id(),
        }

    @classmethod
    def create(cls):
        return cls(Event.create_event_id(), )

    @classmethod
    def create_with_timestamp(cls, timestamp: int):
        return cls.create_from_tuple( (Event.create_event_id_with_timestamp(timestamp), ) )

    @classmethod
    def event_type(cls):
        return cls.__name__

    def timestamp(self):
        return Event.timestamp_from_event_id(self.event_id())

class PlayerOWonGameEvent(tuple, Event):
    """Tuple Class definition for PlayerOWonGameEvent"""

    def __new__(cls, event_id: str):
        try:
            assert isinstance(event_id, str), f'Expected `event_id` to be of type `str` not `{type(event_id)}`'
            return super().__new__(cls, (event_id, ))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 1:
            raise ValueError
        return cls(event_id=tuple_value[0])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def event_id(self) -> str:
        return self[0]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'event_id': self.event_id(),
        }

    @classmethod
    def create(cls):
        return cls(Event.create_event_id(), )

    @classmethod
    def create_with_timestamp(cls, timestamp: int):
        return cls.create_from_tuple( (Event.create_event_id_with_timestamp(timestamp), ) )

    @classmethod
    def event_type(cls):
        return cls.__name__

    def timestamp(self):
        return Event.timestamp_from_event_id(self.event_id())

class NeitherPlayerWonGameEvent(tuple, Event):
    """Tuple Class definition for NeitherPlayerWonGameEvent"""

    def __new__(cls, event_id: str):
        try:
            assert isinstance(event_id, str), f'Expected `event_id` to be of type `str` not `{type(event_id)}`'
            return super().__new__(cls, (event_id, ))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 1:
            raise ValueError
        return cls(event_id=tuple_value[0])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def event_id(self) -> str:
        return self[0]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'event_id': self.event_id(),
        }

    @classmethod
    def create(cls):
        return cls(Event.create_event_id(), )

    @classmethod
    def create_with_timestamp(cls, timestamp: int):
        return cls.create_from_tuple( (Event.create_event_id_with_timestamp(timestamp), ) )

    @classmethod
    def event_type(cls):
        return cls.__name__

    def timestamp(self):
        return Event.timestamp_from_event_id(self.event_id())

class ScoreboardWasUpdatedEvent(tuple, Event):
    """Tuple Class definition for ScoreboardWasUpdatedEvent"""

    def __new__(cls, event_id: str, x_score: int, o_score: int):
        try:
            assert isinstance(event_id, str), f'Expected `event_id` to be of type `str` not `{type(event_id)}`'
            assert isinstance(x_score, int), f'Expected `x_score` to be of type `int` not `{type(x_score)}`'
            assert isinstance(o_score, int), f'Expected `o_score` to be of type `int` not `{type(o_score)}`'
            return super().__new__(cls, (event_id, x_score, o_score))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 3:
            raise ValueError
        return cls(event_id=tuple_value[0], x_score=tuple_value[1], o_score=tuple_value[2])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def event_id(self) -> str:
        return self[0]

    def x_score(self) -> int:
        return self[1]

    def o_score(self) -> int:
        return self[2]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'event_id': self.event_id(),
            'x_score': self.x_score(),
            'o_score': self.o_score(),
        }

    @classmethod
    def create(cls, x_score: int, o_score: int):
        return cls(Event.create_event_id(), x_score, o_score)

    @classmethod
    def create_with_timestamp(cls, timestamp: int, x_score: int, o_score: int):
        return cls.create_from_tuple( (Event.create_event_id_with_timestamp(timestamp), x_score, o_score) )

    @classmethod
    def event_type(cls):
        return cls.__name__

    def timestamp(self):
        return Event.timestamp_from_event_id(self.event_id())

EVENT_TYPES = (PlayerXWonGameEvent, PlayerOWonGameEvent, ScoreboardWasUpdatedEvent)