##
# AUTOGENERATED CODE FILE
##
# from titan.tuple_class_codegen import TupleField, TupleClassCodegen
# 
# 
# def generate_code():
#     yield from TupleClassCodegen.generate_imports()
#     yield from TupleClassCodegen.generate_code('EventMessage', [TupleField.int('seq'),
#                                                                 TupleField.str('event_type'),
#                                                                 TupleField.bytes('event_bytes') ])
#     yield from TupleClassCodegen.generate_code('CommandMessage', [  TupleField.str('command_type'),
#                                                                     TupleField.bytes('command_bytes') ])
#     yield from TupleClassCodegen.generate_code('CommandReceiptMessage', [   TupleField.str('command_receipt_type'),
#                                                                             TupleField.bytes('command_receipt_bytes')  ])
##
import typing
import msgpack
import io

class EventMessage(tuple):
    """Tuple Class definition for EventMessage"""

    def __new__(cls, seq: int, event_type: str, event_bytes: bytes):
        try:
            assert isinstance(seq, int), f'Expected `seq` to be of type `int` not `{type(seq)}`'
            assert isinstance(event_type, str), f'Expected `event_type` to be of type `str` not `{type(event_type)}`'
            assert isinstance(event_bytes, bytes), f'Expected `event_bytes` to be of type `bytes` not `{type(event_bytes)}`'
            return super().__new__(cls, (seq, event_type, event_bytes))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 3:
            raise ValueError
        return cls(seq=tuple_value[0], event_type=tuple_value[1], event_bytes=tuple_value[2])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def seq(self) -> int:
        return self[0]

    def event_type(self) -> str:
        return self[1]

    def event_bytes(self) -> bytes:
        return self[2]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'seq': self.seq(),
            'event_type': self.event_type(),
            'event_bytes': self.event_bytes(),
        }

class CommandMessage(tuple):
    """Tuple Class definition for CommandMessage"""

    def __new__(cls, command_type: str, command_bytes: bytes):
        try:
            assert isinstance(command_type, str), f'Expected `command_type` to be of type `str` not `{type(command_type)}`'
            assert isinstance(command_bytes, bytes), f'Expected `command_bytes` to be of type `bytes` not `{type(command_bytes)}`'
            return super().__new__(cls, (command_type, command_bytes))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 2:
            raise ValueError
        return cls(command_type=tuple_value[0], command_bytes=tuple_value[1])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def command_type(self) -> str:
        return self[0]

    def command_bytes(self) -> bytes:
        return self[1]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'command_type': self.command_type(),
            'command_bytes': self.command_bytes(),
        }

class CommandReceiptMessage(tuple):
    """Tuple Class definition for CommandReceiptMessage"""

    def __new__(cls, command_receipt_type: str, command_receipt_bytes: bytes):
        try:
            assert isinstance(command_receipt_type, str), f'Expected `command_receipt_type` to be of type `str` not `{type(command_receipt_type)}`'
            assert isinstance(command_receipt_bytes, bytes), f'Expected `command_receipt_bytes` to be of type `bytes` not `{type(command_receipt_bytes)}`'
            return super().__new__(cls, (command_receipt_type, command_receipt_bytes))
        except AssertionError as e:
            raise ValueError(str(e))

    @classmethod
    def tuple_type(cls) -> str:
        return cls.__name__

    @classmethod
    def create_from_tuple(cls, tuple_value: tuple):
        if not(isinstance(tuple_value, tuple)) or len(tuple_value) != 2:
            raise ValueError
        return cls(command_receipt_type=tuple_value[0], command_receipt_bytes=tuple_value[1])

    @classmethod
    def create_from_bytes(cls, tuple_bytes: bytes):
        return cls.create_from_tuple(msgpack.unpackb(tuple_bytes, use_list=False, raw=False))

    @classmethod
    def generate_from_stream(cls, buf: io.BytesIO):
        unpacker = msgpack.Unpacker(buf, use_list=False, raw=False)
        for unpacked in unpacker:
            yield cls.create_from_tuple(unpacked)

    def __str__(self):
        return f"{self.tuple_type()}{str(tuple(self))}"

    def __repr__(self):
        return f"{self.tuple_type()}{repr(tuple(self))}"

    def __eq__(self, other):
        return (type(self) == type(other)) and (tuple(self) == tuple(other))

    def __ne__(self, other):
        return (not (self == other))

    def __hash__(self):
        return hash(tuple(self))

    def command_receipt_type(self) -> str:
        return self[0]

    def command_receipt_bytes(self) -> bytes:
        return self[1]

    def serialize_to_bytes(self):
        return msgpack.packb(self, use_bin_type=True)

    def serialize_to_dict(self):
        return {
            'command_receipt_type': self.command_receipt_type(),
            'command_receipt_bytes': self.command_receipt_bytes(),
        }
